Content-Type: multipart/mixed;
	boundary="----_=_NextPart_001_01C13ACD.3529D35E"
Date: Tue, 11 Sep 2001 10:22:37 -0400
From: "Bruno Margerin" <bruno@turbodog.gsfc.nasa.gov>
Subject: RE: [JXTA discuss] start peer in group other than netPeerGroup


Elena,
 
The way I am doing is having a RendezVous/Router Peer for netPeerGroup
also advertising other groups (for me it is the Satella group). Any peer
has this RendezVous/Router Peer in its list and get the Satella Group
Advertisement. But to be exact, the I join the netPeerGroup before
joining the Satella Group. I also use very primitive simple
authentication preventing "group squating"
 
The code is modified pieces from the shell of I can make the code
available, If interested. I wanted to wrtie a tutorial associated with
it, but I can first release the code. 
 
Bruno

==============================================================



http://www.jxta.org/servlets/ReadMsg?msgId=12134&listName=discuss

Date: Tue, 03 Jul 2001 12:53:09 -0400
From: Tom Dengler <tdengler@erols.com>
Content-Type: text/plain; charset=us-ascii
Subject: [JXTA dev] WorldPeerGroup/NetPeerGroup Defnitions - IRC Summary


The following is a summary of a discussion yesterday on the #jxta
channel.
tom

========= summary begins ===========
<chgenly> Eric says: "Now, another confusion we may have, is really
about the nature of the Network Peer Group (or World Group). First of
all, there could be more than one." What does he mean there can be more
than one?  If I write a distribute a jxta app, aren't they all going to
be using the exact same world group def?

<bondolo> There are 3 kinds of groups in jxta: the world peer group, the
net peer group and other regular groups.

The world peer group is entirely local to a peer. each peer
intrinsically knows what the definition of the world peer group is. 
While it has an id, its behaviour is hardcoded into the implementation.
(see platformpeergroup for an example).  The world peer group is about
your phyiscal network topology and your peers physical parameters; those
things which constrain your interaction with other peers.  Every peer is
a member of the world peer group, but that doesnt mean a whole lot and
it certianly doesn't mean they can communicate.  You need connectivity
through the world peer group to send messages at all.

The net peer group builds upon the phyiscal characteristics of your peer
to add the logical constraints.  Things like what your local proxy is,
what you have to do to reach the broader internet.  Net peer group is
generally like dhcp service, automated proxy config, etc.  and will
often be administered for you by your local IS people.

When your peer comes up, it instantiates the world peer group and then
trys to discover the net peer group.  If it does discover something,
then those definitions will assist the peer in making connections.  If
you try to discover the net peer group and dont find anything, then you
can create it yourself with the same definition as the world group.

The world peer group is about phyiscal topology, the net peer group is
about logical topology, regular groups are topology free.
======== summary ends ===========

==============================================================


From: "Brendon J. Wilson" <brendon@pk3i.com>
Date: Mon, 4 Feb 2002 09:02:39 -0800
Content-Type: text/plain;
	charset="iso-8859-1"
Subject: RE: [JXTA dev] Creating my own configurator


Hey Arvind,

The Configurator is kicked off by the net.jxta.impl.peergroup.Platform
class. This class is responsible for creating the World Peer Group, and
primarily relies on the StdPeerGroup and GenericPeerGroup classes in the
same package for most of its functionality. The Platform class is configured
by the PlatformPeerGroupClassName property in the config.properties file in
net.jxta.impl.  You should easily be able to create a class similar to
Platform, and use it to instantiate your own Configurator. Then you could
simply create a different version of the Configurator to work the way you
want.

I might suggest that the reference implementation incorporate a similar way
of configuring the configurator class as is used to configure the Platform
class, thereby eliminating the need to create a copy of the Platform class.
This would require establishing a simple interface for Configurator classes,
thus enabling developers to develop their own Configurator without too much
difficulty. Would this be useful to people? If so, I'll log it as an
enhancement request...

Brendon
-----Original Message-----
From: Arvind [mailto:arvind@alberg.co.in]
Sent: February 4, 2002 1:03 AM
To: dev@jxta.org
Subject: Re: [JXTA dev] Creating my own configurator


Hi,

    I have already checked net.jxta.impl.peergroup.ConfigDialog and
net.jxta.impl.peergroup.Configurator classes. The above classes provides the
Configurator. I donot want that interface. I want to provide my own
interface which is more user friendly. So that user can enter the data more
easily. I want to provide all the four option(Basics, Advanced,
Rendezvous/Relays and Security) in one screen only.

Thanks in Advance

regards
Arvind

==============================================================

Date: Wed, 2 May 2001 17:31:58 -0700 (PDT)
From: Jean-Christophe.Hugly@sun.COM
Content-Type: TEXT/plain; CHARSET=US-ASCII
Subject: [JXTA discuss] Re: Boot, groups, Platform, and initalApp


On 25 Apr, Daniel Rall wrote:
> I was just browsing through the source code, and noticed that the Boot
> class in the impl.platform package doesn't appear to do anything
> (though I'm sure it's there for some reason  ;).  Perhaps a quick note
> stating its purpose is in order?
> 
...
> > I am trying to find out the entry point for InstantP2P.
> >
> > I understand the net.jxta.impl.peergroup.Boot Main is called by the .cpp
> > file.
> >

> Both InstantP2P and Shell are started thru net.jxta.impl.peergroup.Boot. It
> seems to me what controls which app is being launched is by the file,
> jxtaConfig, in the same directory as the exe. The property called
> "InitialNetPeerGroupAppCode" seems to control where the actual app code is.



The Boot class really is sort of an eye candy. Early on
main() was a static method of platform. The reason behind it is this:
Ideally, an application does not see anything outside of the peer group
it runs in (at least as far as JXTA is concerned). Therefore it seems
natural that all the services of the JXTA framework are offered within
the context of a peer group. As a result, launching the JXTA platform
realy means instanciating a PeerGroup that offers a default set of
services, and then starting some application code that lives in that
group. This is pretty much the same idea than the init process for Unix:
the kernel makes itself ready to the point it can handle system calls
and then creates the init process out of one fixed executable file. The
rest is init's business.

You'll notice that jxtaConfig also defines InitialAppCode.
That's actually what "Platform" starts after loading all the service
implementations specified by the other properties such as
"NetPipeCode", "MembershipCode", etc.

Although these are properties so that it is easier to experiment around,
it is not intended for casual editing during normal use. Rather Platform
is intented to be "the JXTA world" a group to which all peers belong and
that always looks the same; the least common denominator. 

The default value of InitialAppCode is "StartNetPeergroup". What it does
is to use the Platform's discovery service to find some group that calls
itself "NetPeerGroup", and instantiate it. What NetPeerGroup is supposed
to be is a first-level of customization. By instanciating such a group,
a Peer complies with the rules of the organization surrounding it and
obtains the discovery, resolver etc. implementations that are supported
inside this organization. Things may well be set-up by sysadmins so that
JXTA traffic outside of the locally published NetPeerGroup can never go
through the firewall nor be routed between subnets inside it.
However, this is still a work in progress and this feature is not
actually used. As a simplification for the time being,
StartNetPeergroup instanciates a "default" hardcoded NetPeerGroup which
looks exactly like "Platform" and which initial app is specified by:
"InitialNetPeerGroupAppCode".

So, in summary, when one runs "the shell", one actually calls Boot.main,
which starts Platform which starts StartNetPeerGroup which starts
NetPeerGroup (actually the class is StdPeerGroup) which starts a Shell.


What instantp2p does is to supply its own jxtaConfig that tweaks the
rules of the game a little bit, by having the "default" NetPeerGroup
start instantp2p instead of a shell. This is probably the simplest way
to do the job as of now, so that people can start playing with
instantp2p. However, this certainly show that there is a problem to be
solved here; what I call the "library mode vs. platform mode" problem.

But since I have made enough noise as it is today, I will ignite that
debate in a subsequent posting.

J-C

==============================================================


jxta book online:

www.brendonwilson.com/projects/jxta

==============================================================

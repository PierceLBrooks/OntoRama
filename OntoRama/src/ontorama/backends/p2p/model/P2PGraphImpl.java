package ontorama.backends.p2p.model;import java.net.URI;import java.util.*;import ontorama.backends.p2p.model.util.NoSuchP2PNodeException;import ontorama.model.graph.Edge;import ontorama.model.graph.GraphModificationException;import ontorama.model.graph.InvalidArgumentException;import ontorama.model.graph.Node;import ontorama.model.graph.GraphImpl;import ontorama.ontotools.NoSuchRelationLinkException;import ontorama.ontotools.query.Query;import ontorama.ontotools.query.QueryResult;import org.tockit.events.EventBroker;/** * Build a collection of GraphNodes and Edges that form a Graph. * GraphBuilder is given a QueryResult (that contains OntologyTypes Iterator) * * This results in acyclic graph which is converted into a tree. * Graph removes all duplicate parents by cloning the children (Removes all * duplicate inbound _graphEdges by cloning outbound _graphEdges) * * Graph holds the root node of the graph. * * <p> * Copyright:    Copyright (c) 2002 * <br> * Company:     DSTC */public class P2PGraphImpl extends GraphImpl implements P2PGraph,Cloneable {	private EventBroker _eventBroker;	public P2PGraphImpl() {        super();        _eventBroker = super.getEventBroker();	}	public P2PGraphImpl(QueryResult queryResult) throws InvalidArgumentException { 		super(queryResult);		_eventBroker = super.getEventBroker();	}    public void add(P2PGraph graph) throws GraphModificationException, NoSuchRelationLinkException {        addEdgesToGraph(graph.getEdgesList());        addNodesToGraph(graph.getNodesList());    }	public void add(QueryResult queryResult) throws GraphModificationException, NoSuchRelationLinkException {        addEdgesToGraph(queryResult.getEdgesList());        addNodesToGraph(queryResult.getNodesList());    }    private void addEdgesToGraph(List edgesList) throws GraphModificationException, NoSuchRelationLinkException {        Iterator it = edgesList.iterator();        while (it.hasNext()) {            this.assertEdge((P2PEdge) it.next(),null);        }    }    private void addNodesToGraph (List nodesList) throws GraphModificationException {        Iterator it = nodesList.iterator();        while (it.hasNext()) {            this.assertNode((P2PNode) it.next(), null);        }    }    /**     * Assert a node.     *     * @param node to assert     * @param userIdUri for the asserter     */     public void assertNode(P2PNode node, URI userIdUri) throws GraphModificationException {        Node tempNode = existSameName(node);        if (tempNode != null) {            if (userIdUri != null) {                ((P2PNode) tempNode).addAssertion(userIdUri);            }        } else {            if (userIdUri != null) {                node.addAssertion(userIdUri);            }        }        System.out.println("assertNode: num of assertions for node " + node.getName() + " is " + node.getAssertions().size());    }    /**     * Reject a node.     *     * @param node to reject     * @param userIdUri for the rejecter     */    public void rejectNode (P2PNode node, URI userIdUri) throws GraphModificationException {        if (userIdUri != null) {            node.addRejection(userIdUri);        }		System.out.println("rejectNode: num of rejections for node " + node.getName() + " is " + node.getRejectionsList().size());    }    /**     * Assert an edge.     *     * @param edge to assert     * @param userIdUri for the asserter     */    public void assertEdge (P2PEdge edge, URI userIdUri) throws GraphModificationException,                                                            NoSuchRelationLinkException {        Edge tmpEdge = existSameEdgeName(edge);        if (tmpEdge != null) {        	if (userIdUri != null) {        		edge.addAssertion(userIdUri);        	}        	        }        else {	        if (userIdUri != null) {	            edge.addAssertion(userIdUri);	        }        }    }    /**     * Reject an edge.     *     * @param edge to reject     * @param userIdUri for the rejecter     */    public void rejectEdge (P2PEdge edge, URI userIdUri)                        	throws GraphModificationException, NoSuchRelationLinkException {        if (userIdUri != null) {            edge.addRejection(userIdUri);        }    }    /**    * Return the searchresult for given Query    * @todo does NOT regard the relation type in the search, uses all relationtypes    */	public P2PGraph search(Query query) {		//keeps track of the depth for every node, the shallowest depth is used for every node		Hashtable queueNodesDepth = new Hashtable();		P2PGraphImpl newExtGraph = new P2PGraphImpl();		String searchedURI = query.getQueryTypeName();		HashSet alreadyProcessedNodes = new HashSet();		try {			P2PGraphImpl extGraph = (P2PGraphImpl) this.clone();			P2PNode searchedNode = extGraph.getP2PNode(searchedURI);			int queryDepth = query.getDepth();			LinkedList queueNodes = new LinkedList();			LinkedList nodesList = new LinkedList();			Iterator edgesIt,nodesIt;			P2PNode currGraphNode,tempGraphNode;			P2PEdge currEdgeObj;			int tempInt = 0;			boolean depthReached = false;			//add searchNode to queue			queueNodes.add(searchedNode);			queueNodesDepth.put(searchedNode,new Integer(0));			while ((!queueNodes.isEmpty()) && !depthReached) {				currGraphNode = (P2PNode) queueNodes.remove(0);				//depth control of search				tempInt = ((Integer) queueNodesDepth.get(currGraphNode)).intValue();				if (tempInt < queryDepth) {										List edgesList = extGraph.getOutboundEdges(currGraphNode);					Iterator it = edgesList.iterator();					while (it.hasNext()) {						Edge edge = (Edge) it.next();						nodesList.add(edge.getToNode());					}										//nodesList = (LinkedList) extGraph.getOutboundEdgeNodes(currGraphNode);					//add Outbound nodes to the queue					queueNodes.addAll(this.getNotProcessedNodesFrom(nodesList, alreadyProcessedNodes));					//add the Outbound nodes (and their depth) to the queue					nodesIt = nodesList.iterator();					while (nodesIt.hasNext()) {						tempGraphNode = (P2PNode) nodesIt.next();						tempInt = ((Integer) queueNodesDepth.get(currGraphNode)).intValue();						tempInt++;						queueNodesDepth.put(tempGraphNode,new Integer(tempInt));					}					//add the Inbound edges to the search result					edgesIt = extGraph.getInboundEdges(currGraphNode).iterator();					while (edgesIt.hasNext()) {						currEdgeObj = (P2PEdge) edgesIt.next();						newExtGraph.addEdge(currEdgeObj);					}				} else {					depthReached = true;				}			}		} catch (NoSuchP2PNodeException e) {			System.err.println("The node you searched for can not be found:" + searchedURI);            e.printStackTrace();		} catch (GraphModificationException e) {			System.err.println("Error");            e.printStackTrace();		} catch (NoSuchRelationLinkException e) {			System.err.println("No relation of that type found");            e.printStackTrace();		} catch (CloneNotSupportedException e) {			System.err.println("This object can not be cloned");            e.printStackTrace();		}		return newExtGraph;	}	private Collection getNotProcessedNodesFrom(Collection nodesList, Collection alreadyProccesedNodes) {		Iterator listIt = nodesList.iterator();		LinkedList retVal = new LinkedList();		P2PNode currGraphNode;		while (listIt.hasNext()) {			currGraphNode = (P2PNode) listIt.next();			if (!alreadyProccesedNodes.contains(currGraphNode.getIdentifier())) {				alreadyProccesedNodes.add(currGraphNode.getIdentifier());				retVal.add(currGraphNode);			}		}		return retVal;	}	public P2PNode getP2PNode(String nodeUri) throws NoSuchP2PNodeException {		Iterator it = this.getNodesList().iterator();		P2PNode currNode = null;		while (it.hasNext()) {            Object obj = it.next();            //System.out.println("object = " + obj + " class = " + obj.getClass() );            currNode = (P2PNode) obj;			//currNode = (P2PNode) it.next();			if ((currNode.getIdentifier().equals(nodeUri)) || (currNode.getName().equals(nodeUri))) {                System.out.println("FOUND node: " + currNode);				return currNode;			}		}        System.out.println("DIDN'T FIND node " + nodeUri);		throw new NoSuchP2PNodeException("Could not find a node with the name:" + nodeUri);	}			}
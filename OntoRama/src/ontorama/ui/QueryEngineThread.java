package ontorama.ui;import java.io.IOException;import ontorama.ontotools.CancelledQueryException;import ontorama.ontotools.NoSuchRelationLinkException;import ontorama.ontotools.NoSuchTypeInQueryResult;import ontorama.ontotools.ParserException;import ontorama.ontotools.SourceException;import ontorama.ontotools.query.Query;import ontorama.ontotools.query.QueryEngine;import ontorama.ontotools.query.QueryResult;import ontorama.model.graph.Graph;import ontorama.model.graph.GraphImpl;import ontorama.model.graph.NoTypeFoundInResultSetException;import org.tockit.events.EventBroker;/** * <p>Title: </p> * <p>Description: Using given query get a graph for this query on a * separate thread. * </p> * <p>Copyright: Copyright (c) 2002</p> * <p>Company: DSTC</p> * @author nataliya * @version 1.0 */public class QueryEngineThread extends Thread {    /**     * query     */    private Query _query;    /**     * graph that will be built as a result of query     */    private Graph _graph;    /**     * status message     */    private String _status = "";    /**     * level of progress.     * may be used by progress bar     */    private int _current = 0;    /**     * flag to indicate if task is finished     */    private boolean _finished = false;    /**     * @todo probably shouldn't pass event broker here     */    EventBroker _eventBroker;    /**     * Constructor.     */    public QueryEngineThread(Query query, EventBroker eventBroker) {        super();        _query = query;        _eventBroker = eventBroker;        initAll();    }    /**     * initialise all vars     */    private void initAll() {        _current = 0;        _finished = false;        _graph = null;    }    /**     * Overriting Thread run() method. This method will do all the work.     *     * @todo not sure of mechanism for interruting thread is correct.     * Problem: once the thread is interrupted, it propagates to QueryEngine, etc.     * However, these processes don't stop because they are designed by java to     * stop gracefully (finish whatever they are doing). In our case we don't want     * that - we want to stop a long process at once. To achieve this: we modified     * Source interface and WebKB2Source code to throw CacelledQueryException.     * Source checks if it's thread has been interrupted and if it was - it throws     * CancelledQueryException. This insures that all processes are stopped immediately.     * Not sure if this is a hack, because it's a bit unintuative: this class     * interrupts the thread and at the same time gets an exception that has been     * caused by the interruption. Also, this approach is very dependant on Source     * implementation: if Source is performing a few tasks in order to do its job,     * each task would have to check if thread is interrupted and throw     * the exception. this is relying on the developer too much.     */    public void run() {        initAll();        try {            _status = "getting ontology data from the source";            _current = 30;            QueryEngine queryEngine = new QueryEngine(_query);            _status = "ontology data is read, building data structures";            _current = 60;            QueryResult queryResult = queryEngine.getQueryResult();            _status = "building graph";            _current = 90;            _graph = new GraphImpl(queryResult, _eventBroker);            _status = "graph is built";        } catch (NoTypeFoundInResultSetException noTypeExc) {            System.err.println(noTypeExc);            OntoRamaApp.showErrorDialog(noTypeExc.getMessage());        } catch (NoSuchRelationLinkException noRelExc) {            System.err.println(noRelExc);            OntoRamaApp.showErrorDialog(noRelExc.getMessage());        } catch (IOException ioExc) {            System.out.println(ioExc);            ioExc.printStackTrace();            OntoRamaApp.showErrorDialog(ioExc.getMessage());        } catch (ParserException parserExc) {            System.out.println(parserExc);            parserExc.printStackTrace();            OntoRamaApp.showErrorDialog(parserExc.getMessage());        } catch (ClassNotFoundException classExc) {            System.out.println(classExc);            classExc.printStackTrace();            OntoRamaApp.showErrorDialog("Sorry, couldn't find one of the classes you specified in config.xml");        } catch (IllegalAccessException iae) {            System.out.println(iae);            iae.printStackTrace();            OntoRamaApp.showErrorDialog(iae.getMessage());        } catch (InstantiationException instExc) {            System.out.println(instExc);            instExc.printStackTrace();            OntoRamaApp.showErrorDialog(instExc.getMessage());        } catch (NoSuchTypeInQueryResult noSuchTypeExc) {            System.err.println(noSuchTypeExc);            noSuchTypeExc.printStackTrace();            OntoRamaApp.showErrorDialog(noSuchTypeExc.getMessage());        } catch (SourceException sourceExc) {            System.err.println(sourceExc);            sourceExc.printStackTrace();            OntoRamaApp.showErrorDialog(sourceExc.getMessage());        } catch (CancelledQueryException cancelledExc) {            if (!isInterrupted()) {                System.err.println("got CancelledQueryException when didn't try to interrupt the query!");                cancelledExc.printStackTrace();                OntoRamaApp.showErrorDialog("Unexpected exception: query was cancelled");            }        } catch (Exception e) {            System.err.println();            e.printStackTrace();            OntoRamaApp.showErrorDialog("Unable to build graph, unexpected error.");        }        _finished = true;        _current = 98;    }    /**     * get current status message     */    public String getMessage() {        return _status;    }    /**     * get current progress level     */    public int getCurrent() {        return _current;    }    /**     * get graph that has been built     */    public Graph getGraph() {        return _graph;    }    /**     * return flag indicating if task has been finished     */    public boolean done() {        return _finished;    }    /**     * return flag indicating if task has been stopped     */    public boolean isStopped() {        return isInterrupted();    }    /**     * stop this thread     */    public void stopProcess() {        interrupt();        _graph = null;    }}